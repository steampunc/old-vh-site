
	compare() {
		var transitive_lists = generateHierarchies(this.getNodes());
		var similarity = {};
		for (var i = 0; i < transitive_lists.length; i++) {
			similarity[transitive_lists[i]] = 0;
			for (var j = 0; j < transitive_lists[i].length; j++) {
				var node = transitive_lists[i][j]; 
				var lower_nodes = transitive_lists[i].slice(j + 1, transitive_lists.length);
				var graph_lower_nodes = this.getEdges(node);

				similarity[transitive_lists[i]] += graph_lower_nodes.length * Math.atan(lower_nodes.length - graph_lower_nodes.length);

			}
	
		}

		var tangent_hierarchies = Object.keys(similarity).map(function(key) {
			return [key, similarity[key]];
		});	

		tangent_hierarchies.sort(function(val1, val2) {
			return val2[1] - val1[1]; 
		});

		var possible_hierarchies = [];

		possible_hierarchies.push(tangent_hierarchies[0][0].split(","));
		console.log(tangent_hierarchies);
		return possible_hierarchies;
	}


	check_cycles(colors, node, cycle) {
		colors[node] = "G";


		var edges = this.getEdges(node);
		for (var i = 0; i < edges.length; i++) { 
			var edge = edges[i];
	
			if (colors[edge] == "G") {	
				cycle.push(edge);
				return true;	
			}

			if (colors[edge] == "W" && this.check_cycles(colors, edge, cycle)) {
				cycle.push(edge);
				return true;
			}
		}

		colors[node] = "B";
		return false;

	}

function findCycles(graph) {
	var cycles = [];

	var nodes = graph.getNodes();
	for (var i = 0; i < nodes.length; i++) {
		var colors = {}
		graph.getNodes().forEach(function(node) {
			colors[node] = "W";
		});

		var cycle = [];
		if (graph.check_cycles(colors, nodes[i], cycle)) {

			cycles.push(cycle);
		}
	}


	subgraphs = graph.findSubgraphs();
	for (var i = 0; i < subgraphs.length; i++) {
		console.log(findCycles(subgraphs[i]));
	}

	return cycles;
}
